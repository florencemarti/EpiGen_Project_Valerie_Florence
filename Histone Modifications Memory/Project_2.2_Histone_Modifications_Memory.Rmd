---
title: "Project_2.2_Histone_Modifications_BG_"
author: "Florence Marti"
date: "2025-06-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Documents/GitHub/EpiGen_Project_Valerie_Florence/Histone Modifications Memory")
```

```{r, include = FALSE}
suppressPackageStartupMessages({
  library(AnnotationHub)
  library(ensembldb)
  library(GenomicRanges)
  library(epiwraps)
  library(rtracklayer)
  library(ggplot2)
  library(magick)
  library(R.utils) 
  library(MASS)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(org.Hs.eg.db)
  library(AnnotationDbi)
  library(valr)
  library(EnrichedHeatmap)
})
```

# Importing the downloaded data
In this part I imported the peaks for the histone modifications H3K4me3, H3K4me1, and H3K27ac for monocytes (M0), macrophages (mf), and beta-glucan primed macrophages (BG). Additionally I imported the list of human TF's that play a role in macrophage polarisation.

For this part of the analysis, we use the peaks that they published as txt files. They shared one txt file per histone modification and for simplicity, we edited the txt files in excel before importing them into the document. We created one txt file per cell type per histone modification and then converted them to .bed files in the chunk below using code generated by ChatGPT. Using this approach, we created files with the same sequences as peaks but different intensities. Therefore I wanted to use the signal intensity to compare the peaks found in naive and memory T cells. 

The txtfiles used in the analysis have the strucutre shown below. 

For the analysis, we split the workload in comparing naive and memory cells (part 1), and naive and exhausted cells (part 2). 

```{r}
head(read.table("peaks/H3K27ac.txt", header = TRUE))
```

```{r}
setwd("~/Documents/GitHub/EpiGen_Project_Valerie_Florence/Histone Modifications Memory/peaks")

# H3K27ac
H3K27ac_df <- read.table("H3K27ac.txt", header = TRUE)

# H3K27me3
H3K27me3_df <- read.table("H3K27me3.txt", header = TRUE)

# H3K4me3
H3K4me3_df <- read.table("H3K4me3.txt", header = TRUE)

# H3K9me3
H3K9me3_df <- read.table("H3K9me3.txt", header = TRUE)

# Converting to GRanges


H3K27ac_gr <- GRanges(seqnames = H3K27ac_df$peakN, ranges = IRanges(start = H3K27ac_df$Start, end = H3K27ac_df$End))

H3K27me3_gr <- GRanges(seqnames = H3K27me3_df$Chr, ranges = IRanges(start = H3K27me3_df$Start, end = H3K27me3_df$End))
H3K4me3_gr <- GRanges(seqnames = H3K4me3_df$Chr, ranges = IRanges(start = H3K4me3_df$Start, end = H3K4me3_df$End))
H3K9me3_gr <- GRanges(seqnames = H3K9me3_df$Chr, ranges = IRanges(start = H3K9me3_df$Start, end = H3K9me3_df$End))



# Create GRanges List

peaks <- GRangesList(
  H3K27ac = H3K27ac_gr,
  H3K27me3 = H3K27me3_gr,
  H3K4me3 = H3K4me3_gr,
  H3K9me3 = H3K9me3_gr
)


```

```{r}
# 
regionUpset(peaks)
```

```{r}
# Naive = cols 7:10, Memory = cols 15:18
H3K27ac_signal <- cbind(
  naive = H3K27ac_df[, 7:10],
  memory = H3K27ac_df[, 15:18]
)
H3K27me3_signal <- cbind(
  naive = H3K27me3_df[, 7:10],
  memory = H3K27me3_df[, 15:18]
)
H3K4me3_signal <- cbind(
  naive = H3K4me3_df[, 7:10],
  memory = H3K4me3_df[, 15:18]
)
H3K9me3_signal <- cbind(
  naive = H3K9me3_df[, 7:10],
  memory = H3K9me3_df[, 15:18]
)


rownames(H3K27ac_signal) <- paste(H3K27ac_df$peakN)
rownames(H3K27me3_signal) <- paste(H3K27me3_df$peakN)
rownames(H3K4me3_signal)  <- paste(H3K4me3_df$peakN)
rownames(H3K9me3_signal)  <- paste(H3K9me3_df$peakN)

```

Since in the upset plots we were not able to see any changes in histone modification I chose to visualise the intensities provided in the txt files for naive and memory T cells. The first step was to extract the signal intensities for the columns of interest, for me the columns 7-10 (naive T cells on day 30), and columns 15-18 (memory T cells on day 30), and then name the rows after chromosome, start, and end of the peak. Next, I calculated the log2(mean signal intensity) of each cell type to filter for significant intensity differences, threshold was set to 0.1. After filtering the data for significance (in both directions), I z-scored the intensities by scaling it and then visualised the data in a heatmap for all the histone marks. 

# H3K4me3
```{r}
# Compute mean signal per group for each row
mean_naive_H3K4me3 <- rowMeans(H3K4me3_signal[, 1:4])   # naive cols
mean_memory_H3K4me3 <- rowMeans(H3K4me3_signal[, 5:8])  # memory cols

# Compute log2 fold change (memory / naive), add small pseudocount to avoid log2(0)
pseudocount <- 1e-6
log2FC_H3K4me3 <- log2((mean_memory_H3K4me3 + pseudocount) / (mean_naive_H3K4me3 + pseudocount))

# Optionally, check distribution
summary(log2FC_H3K4me3)

# Filter rows with log2FC > 0.1 (you can add abs(log2FC) > 0.1 if you want both directions)
sig_rows_H3K4me3 <- which(abs(log2FC_H3K4me3) > 0.1)

# Subset the original signal matrix to significant rows only
sig_H3K4me3_signal <- H3K4me3_signal[sig_rows_H3K4me3, ]

# Scale the signal matrix for plotting
scaled_signal_H3K4me3 <- t(scale(t(sig_H3K4me3_signal)))  
# Scale rows (regions) - so each region is mean 0, sd 1


pheatmap(scaled_signal_H3K4me3, main = "H3K4me3 (Naive & Memory) Significant Regions", show_rownames = FALSE, cutree_rows = 2)
```

# H3K27ac
```{r}
# Compute mean signal per group for each row
mean_naive_H3K27ac <- rowMeans(H3K27ac_signal[, 1:4])   # naive cols
mean_memory_H3K27ac <- rowMeans(H3K27ac_signal[, 5:8])  # memory cols

# Compute log2 fold change (memory / naive), add small pseudocount to avoid log2(0)
pseudocount <- 1e-6
log2FC_H3K27ac <- log2((mean_memory_H3K27ac + pseudocount) / (mean_naive_H3K27ac + pseudocount))

# Filter rows with log2FC > 0.1 (you can add abs(log2FC) > 0.1 if you want both directions)
sig_rows_H3K27ac <- which(abs(log2FC_H3K27ac) > 0.1)

# Subset the original signal matrix to significant rows only
sig_H3K27ac_signal <- H3K27ac_signal[sig_rows_H3K27ac, ]

# Scale the signal matrix for plotting
scaled_signal_H3K27ac <- t(scale(t(sig_H3K27ac_signal)))  
# Scale rows (regions) - so each region is mean 0, sd 1

# Plot heatmap
pheatmap(scaled_signal_H3K27ac, main = "H3K27ac (Naive & Memory) Significant Regions", show_rownames = FALSE, cutree_rows = 2)

```

# H3K27me3
```{r}
# Compute mean signal per group for each row
mean_naive_H3K27me3 <- rowMeans(H3K27me3_signal[, 1:4])   # naive cols
mean_memory_H3K27me3 <- rowMeans(H3K27me3_signal[, 5:8])  # memory cols

# Compute log2 fold change (memory / naive), add small pseudocount to avoid log2(0)
pseudocount <- 1e-6
log2FC_H3K27me3 <- log2((mean_memory_H3K27me3 + pseudocount) / (mean_naive_H3K27me3 + pseudocount))


# Filter rows with log2FC > 0.1 (you can add abs(log2FC) > 0.1 if you want both directions)
sig_rows_H3K27me3 <- which(abs(log2FC_H3K27me3) > 0.1)

# Subset the original signal matrix to significant rows only
sig_H3K27me3_signal <- H3K27me3_signal[sig_rows_H3K27me3, ]

# Scale the signal matrix for plotting
scaled_signal_H3K27me3 <- t(scale(t(sig_H3K27me3_signal)))  
# Scale rows (regions) - so each region is mean 0, sd 1

# Plot heatmap
pheatmap(scaled_signal_H3K27me3, main = "H3K27me3 (Naive & Memory) Significant Regions", show_rownames = FALSE, cutree_rows = 2)
```

# H3K9me3
```{r}
# Compute mean signal per group for each row
mean_naive_H3K9me3 <- rowMeans(H3K9me3_signal[, 1:4])   # naive cols
mean_memory_H3K9me3 <- rowMeans(H3K9me3_signal[, 5:8])  # memory cols

# Compute log2 fold change (memory / naive), add small pseudocount to avoid log2(0)
pseudocount <- 1e-6
log2FC_H3K9me3 <- log2((mean_memory_H3K9me3 + pseudocount) / (mean_naive_H3K9me3 + pseudocount))


# Filter rows with log2FC > 0.1 (you can add abs(log2FC) > 0.1 if you want both directions)
sig_rows_H3K9me3 <- which(abs(log2FC_H3K9me3) > 0.1)

# Subset the original signal matrix to significant rows only
sig_H3K9me3_signal <- H3K9me3_signal[sig_rows_H3K9me3, ]

# Scale the signal matrix for plotting
scaled_signal_H3K9me3 <- t(scale(t(sig_H3K9me3_signal)))  
# Scale rows (regions) - so each region is mean 0, sd 1

# Plot heatmap
pheatmap(scaled_signal_H3K9me3, main = "H3K9me3 (Naive & Memory) Significant Regions", show_rownames = FALSE, cutree_rows = 2)
```


```{r}
# List of all scaled matrices
scaled_list <- list(scaled_signal_H3K4me3, scaled_signal_H3K27ac, scaled_signal_H3K27me3, scaled_signal_H3K9me3)

# Get union of all rownames (regions)
all_regions <- Reduce(union, lapply(scaled_list, rownames))

# Function to add missing rows with zeros and reorder rows by all_regions
fill_missing_rows <- function(mat, all_rows) {
  missing <- setdiff(all_rows, rownames(mat))
  if(length(missing) > 0) {
    # Create zero matrix for missing rows
    zero_mat <- matrix(0, nrow = length(missing), ncol = ncol(mat),
                       dimnames = list(missing, colnames(mat)))
    # Bind existing matrix and zero rows
    mat <- rbind(mat, zero_mat)
  }
  # Reorder rows
  mat[all_rows, , drop = FALSE]
}

# Apply function to each scaled matrix
scaled_filled <- lapply(scaled_list, fill_missing_rows, all_rows = all_regions)

# Combine all columns together (all samples from all histone mods)
combined_scaled <- do.call(cbind, scaled_filled)

```

```{r}
# Get colnames for each scaled matrix (samples)
samples_H3K4me3  <- colnames(scaled_filled[[1]])
samples_H3K27ac  <- colnames(scaled_filled[[2]])
samples_H3K27me3 <- colnames(scaled_filled[[3]])
samples_H3K9me3  <- colnames(scaled_filled[[4]])

all_samples <- c(samples_H3K4me3, samples_H3K27ac, samples_H3K27me3, samples_H3K9me3)

# Assuming 4 naive + 4 memory per histone modification, adjust if different
annotation_col <- data.frame(
  CellType = rep(c("Naive", "Memory"), times = c(4,4)),
  HistoneMark = rep(c("H3K4me3", "H3K27ac", "H3K27me3", "H3K9me3"), each = 8)
)
rownames(annotation_col) <- all_samples

```

```{r, fig.cap=}
top_rows <- head(order(apply(combined_scaled, 1, var), decreasing = TRUE), 15000)
pheatmap(combined_scaled[top_rows, ],
         annotation_col = annotation_col,
         show_colnames = FALSE,
         show_rownames = FALSE,
         main = "Scaled Signal Intensity Across Histone Marks and Cell Types",
         cluster_rows = TRUE,
         cluster_cols = F)
```
Now I want to determine the rows that are activated e.g. upregulation of activation, or downregulation of expression
```{r}
# Extract memory signals by mark
mem_H3K4me3  <- combined_scaled[, 5:8]
mem_H3K27ac  <- combined_scaled[, 13:16]
mem_H3K27me3 <- combined_scaled[, 21:24]
mem_H3K9me3  <- combined_scaled[, 29:32]

# Logical checks per row:
# 1) H3K4me3 AND H3K27ac UPREGULATED (≥0) in any memory sample
up_H3K4me3  <- apply(mem_H3K4me3, 1, function(x) all(x >= 0))
up_H3K27ac  <- apply(mem_H3K27ac, 1, function(x) all(x >= 0))

# 2) H3K27me3 AND H3K9me3 DOWNREGULATED (≤0) in any memory sample
down_H3K27me3 <- apply(mem_H3K27me3, 1, function(x) all(x <= 0))
down_H3K9me3  <- apply(mem_H3K9me3, 1, function(x) all(x <= 0))

# Combine conditions: BOTH marks up AND BOTH marks down per row
select_rows <- which((up_H3K4me3 & up_H3K27ac) & (down_H3K27me3 & down_H3K9me3))

# Filtered memory subset for these rows, all memory columns
memory_up <- combined_scaled[select_rows, c(5:8, 13:16, 21:24, 29:32)]

# Exclude rows that contain any zero in these memory columns
memory_up <- memory_up[!apply(memory_up == 0, 1, any), ]

# Check dimensions and rownames
dim(memory_up)

dir.create("files")
write.csv(memory_up, file = "files/memory_up_peaks_signal.csv", row.names = T)
```
Peaks that are downregulated in memory cells compared to naive t cells
```{r}
# 1) H3K4me3 AND H3K27ac UPREGULATED (≥0) in any memory sample
down_H3K4me3  <- apply(mem_H3K4me3, 1, function(x) all(x <= 0))
down_H3K27ac  <- apply(mem_H3K27ac, 1, function(x) all(x <= 0))

# 2) H3K27me3 AND H3K9me3 DOWNREGULATED (≤0) in any memory sample
up_H3K27me3 <- apply(mem_H3K27me3, 1, function(x) all(x >= 0))
up_H3K9me3  <- apply(mem_H3K9me3, 1, function(x) all(x >= 0))

# Combine conditions: BOTH marks up AND BOTH marks down per row
select_rows_d <- which((down_H3K4me3 & down_H3K27ac) & (up_H3K27me3 & up_H3K9me3))

# Filtered memory subset for these rows, all memory columns
memory_down <- combined_scaled[select_rows_d, c(5:8, 13:16, 21:24, 29:32)]

# Exclude rows that contain any zero in these memory columns
memory_down <- memory_down[!apply(memory_down == 0, 1, any), ]

# Check dimensions and rownames
dim(memory_down)

write.csv(memory_down, file= "files/memory_down_peaks_signal.csv", row.names = T)
```
From now on I want to look at the rows that I definded in memory_up and memory_down to be up or downregulated respectively in memory cells. furthermore, these peaks are present in all of the histone modifications. Using this intersection we can represent regions with coordinated chromatin changes.
```{r}

selected_rows <- union(rownames(memory_up), rownames(memory_down))

memory_up_and_down <- combined_scaled[selected_rows, ]
dim(combined_scaled)
dim(memory_up_and_down)

pheatmap(memory_up_and_down, annotation_col = annotation_col,
         show_colnames = FALSE,
         show_rownames = FALSE,
         main = "Up- and Downregulated Scaled Signal Intensity Across Histone Marks and Cell Types",
         cluster_rows = TRUE,
         cluster_cols = F,
         cutree_rows = 2)

```
Using this approach we decrease the size of the dataset for comparing naive and memory T cells to 308 peaks, which is substantially less than the initial 45174 peaks we looked at.

```{r}
# Vector of peaks to keep
peaks_to_keep <- rownames(memory_up_and_down)

# Filter each data frame by peakN
H3K27ac_filtered_df <- H3K27ac_df[H3K27ac_df$peakN %in% peaks_to_keep, ]
H3K27me3_filtered_df <- H3K27me3_df[H3K27me3_df$peakN %in% peaks_to_keep, ]
H3K4me3_filtered_df  <- H3K4me3_df[H3K4me3_df$peakN %in% peaks_to_keep, ]
H3K9me3_filtered_df  <- H3K9me3_df[H3K9me3_df$peakN %in% peaks_to_keep, ]

H3K27ac_filtered_gr <- makeGRangesFromDataFrame(
  H3K27ac_filtered_df,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end",
  strand.field = "strand",
  keep.extra.columns = F
)

H3K4me3_filtered_gr <- makeGRangesFromDataFrame(
  H3K4me3_filtered_df,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end",
  strand.field = "strand",
  keep.extra.columns = F
)

H3K27me3_filtered_gr <- makeGRangesFromDataFrame(
  H3K27me3_filtered_df,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end",
  strand.field = "strand",
  keep.extra.columns = F
)

H3K9me3_filtered_gr <- makeGRangesFromDataFrame(
  H3K9me3_filtered_df,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end",
  strand.field = "strand",
  keep.extra.columns = F
)

peaks_filtered <- GRangesList(
  H3K27ac = H3K27ac_filtered_gr,
  H3K27me3 = H3K27me3_filtered_gr,
  H3K4me3 = H3K4me3_filtered_gr,
  H3K9me3 = H3K9me3_filtered_gr
)

regionUpset(peaks_filtered)
```
```{r, warning=F, include = F, eval=T}
rm(mean_naive_H3K27ac, mean_memory_H3K27ac, mean_naive_H3K27me3, mean_memory_H3K27me3,mean_naive_H3K4me3, mean_memory_H3K4me3, mean_naive_H3K9me3, mean_memory_H3K9me3, pseudocount, H3K27ac_df, H3K27me3_df, H3K4me3_df, H3K9me3_signal,H3K27ac_signal, H3K27me3_signal, H3K4me3_signal, scaled_signal_H3K27ac, scaled_signal_H3K27me3, scaled_signal_H3K4me3, scaled_signal_H3K9me3, sig_H3K27ac_signal, sig_H3K27me3_signal, sig_H3K4me3_signal, sig_H3K9me3_signal, down_H3K27ac, down_H3K27me3, down_H3K4me3, down_H3K9me3, up_H3K27ac, up_H3K27me3, up_H3K4me3, up_H3K9me3, sig_rows_H3K27ac, sig_rows_H3K27me3, sig_rows_H3K4me3, sig_rows_H3K9me3, log2FC_H3K27ac, log2FC_H3K27me3, log2FC_H3K4me3, log2FC_H3K9me3)
```

# Comparing the histone modifications of naive T cells

```{r}
setwd("~/Documents/GitHub/EpiGen_Project_Valerie_Florence/Histone Modifications Memory")

# Naive
bwfiles_naive <- list.files("bigwig_files", pattern = "_naive.bw$", full.names = TRUE)
names(bwfiles_naive) <- gsub("\\.bw$", "", basename(bwfiles_naive))

naive_regions <- reduce(unlist(GRangesList(peaks)))
sm_n <- signal2Matrix(bwfiles_naive, regions = naive_regions, w = 40)


naive_regions_f <- reduce(unlist(GRangesList(peaks_filtered)))
sm_n_filtered <- signal2Matrix(bwfiles_naive, regions = naive_regions_f, w = 40)

# Memory
bwfiles_memory <- list.files("bigwig_files", pattern = "_memory.bw$", full.names = TRUE)
names(bwfiles_memory) <- gsub("\\.bw$", "", basename(bwfiles_memory))

memory_regions <- reduce(unlist(GRangesList(peaks)))
sm_m <- signal2Matrix(bwfiles_memory, regions = memory_regions, w = 40)

memory_regions_f <- reduce(unlist(GRangesList(peaks_filtered)))
sm_m_filtered <- signal2Matrix(bwfiles_memory, regions = memory_regions_f, w = 40)
```


```{r}
```
Comparing the enriched heatmaps of all of the peaks and the peaks we filtered out as significant
```{r}
plotEnrichedHeatmaps(sm_n, trim = 0.05)
```


```{r}
plotEnrichedHeatmaps(sm_n_filtered, trim = 0.05)
```
```{r}
plotEnrichedHeatmaps(sm_m, trim=0.05)
```


```{r}
plotEnrichedHeatmaps(sm_m, trim=0.05)

meanEnrichment <- rowMeans(score(sm_m))
sm_m_2 <- sm_m[which(meanEnrichment >= median(meanEnrichment)),]

plotEnrichedHeatmaps(sm_m_2)
```

